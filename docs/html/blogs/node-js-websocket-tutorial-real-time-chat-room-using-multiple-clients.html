<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Node.js WebSocket Tutorial — Real-Time Chat Room using Multiple Clients &mdash; WebSockets Docs v2019.0613 文档</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script src="../_static/translations.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="prev" title="Blogs" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../contents.html" class="icon icon-home"> WebSockets Docs
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">WebSockets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api/index.html">API documention</a></li>
<li class="toctree-l1"><a class="reference internal" href="../awesome.html">Awesome WebSockets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../socket.io/index.html">socket.io documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ws/index.html">ws 文档</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Blogs</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Node.js WebSocket Tutorial — Real-Time Chat Room using Multiple Clients</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../contents.html">WebSockets Docs</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="../contents.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Blogs</a></li>
      <li class="breadcrumb-item active">Node.js WebSocket Tutorial — Real-Time Chat Room using Multiple Clients</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/blogs/node-js-websocket-tutorial-real-time-chat-room-using-multiple-clients.rst.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="node-js-websocket-tutorial-real-time-chat-room-using-multiple-clients">
<h1>Node.js WebSocket Tutorial — Real-Time Chat Room using Multiple Clients<a class="headerlink" href="#node-js-websocket-tutorial-real-time-chat-room-using-multiple-clients" title="此标题的永久链接"></a></h1>
<p>&gt; <a class="reference external" href="https://karlhadwen.medium.com/node-js-websocket-tutorial-real-time-chat-room-using-multiple-clients-44a8e26a953e">https://karlhadwen.medium.com/node-js-websocket-tutorial-real-time-chat-room-using-multiple-clients-44a8e26a953e</a></p>
<p>Karl Hadwen
Karl Hadwen</p>
<p>May 29·6 min read</p>
<p>WebSockets don’t have to be scary! Let’s create a multi-client real-time chat room together!
We are going to be using the following packages for this tutorial:
WS: <a class="reference external" href="https://github.com/websockets/ws">https://github.com/websockets/ws</a>
Express: <a class="reference external" href="https://github.com/expressjs/express">https://github.com/expressjs/express</a>
WS is simple to use, blazing fast and thoroughly tested WebSocket client and server for Node.js — their words, not mine…although I am partial to agree as it works fantastically!
Install our dependencies
yarn add express ws
If you are using npm, you can install the dependencies that we need for this tutorial by using npm install express ws
{</p>
<blockquote>
<div><p>“name”: “rtm”,
“version”: “0.0.1”,
“scripts”: {</p>
<blockquote>
<div><p>“start”: “node server.js”</p>
</div></blockquote>
<p>},
“dependencies”: {</p>
<blockquote>
<div><p>“express”: “^4.17.1”,
“ws”: “^7.2.5”</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
Don’t worry if your version numbers on the dependencies are different, the authors of the packages could have updated the modules and thus resulting in the version numbers increasing.
Creating our server.js file
const express = require(‘express’);
const http = require(‘http’);
const WebSocket = require(‘ws’);</p>
<p>const port = 6969;
const server = http.createServer(express);
const wss = new WebSocket.Server({ server })</p>
<dl>
<dt>wss.on(‘connection’, function connection(ws) {</dt><dd><dl>
<dt>ws.on(‘message’, function incoming(data) {</dt><dd><dl>
<dt>wss.clients.forEach(function each(client) {</dt><dd><dl class="simple">
<dt>if (client !== ws &amp;&amp; client.readyState === WebSocket.OPEN) {</dt><dd><p>client.send(data);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>})</p>
</dd>
</dl>
<p>})</p>
</dd>
</dl>
<p>})</p>
<dl class="simple">
<dt>server.listen(port, function() {</dt><dd><p>console.log(<cite>Server is listening on ${port}!</cite>)</p>
</dd>
</dl>
<p>})
There isn’t that much going on here, but it would be great to walk through the code line by line to figure out how this works exactly. If you get the idea as to what’s going on here, great! If not, check the detailed overview below 👇
Creating our index.html file
&lt;h1&gt;Real Time Messaging&lt;/h1&gt;
&lt;pre id=”messages” style=”height: 400px; overflow: scroll”&gt;&lt;/pre&gt;
&lt;input type=”text” id=”messageBox” placeholder=”Type your message here” style=”display: block; width: 100%; margin-bottom: 10px; padding: 10px;” /&gt;
&lt;button id=”send” title=”Send Message!” style=”width: 100%; height: 30px;”&gt;Send Message&lt;/button&gt;</p>
<dl>
<dt>&lt;script&gt;</dt><dd><dl>
<dt>(function() {</dt><dd><p>const sendBtn = document.querySelector(‘#send’);
const messages = document.querySelector(‘#messages’);
const messageBox = document.querySelector(‘#messageBox’);</p>
<p>let ws;</p>
<dl class="simple">
<dt>function showMessage(message) {</dt><dd><p>messages.textContent += <cite>nn${message}</cite>;
messages.scrollTop = messages.scrollHeight;
messageBox.value = ‘’;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>function init() {</dt><dd><dl class="simple">
<dt>if (ws) {</dt><dd><p>ws.onerror = ws.onopen = ws.onclose = null;
ws.close();</p>
</dd>
</dl>
<p>}</p>
<p>ws = new WebSocket(‘ws://localhost:6969’);
ws.onopen = () =&gt; {</p>
<blockquote>
<div><p>console.log(‘Connection opened!’);</p>
</div></blockquote>
<p>}
ws.onmessage = ({ data }) =&gt; showMessage(data);
ws.onclose = function() {</p>
<blockquote>
<div><p>ws = null;</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>sendBtn.onclick = function() {</dt><dd><dl class="simple">
<dt>if (!ws) {</dt><dd><p>showMessage(“No WebSocket connection :(“);
return ;</p>
</dd>
</dl>
<p>}</p>
<p>ws.send(messageBox.value);
showMessage(messageBox.value);</p>
</dd>
</dl>
<p>}</p>
<p>init();</p>
</dd>
</dl>
<p>})();</p>
</dd>
</dl>
<p>&lt;/script&gt;
How does the code work?
Showing the final code is great, but how exactly does it all connect and work together? Fine, you win! Let’s go ahead and dissect the server.js file!
const express = require(‘express’);
const http = require(‘http’);
const WebSocket = require(‘ws’);</p>
<p>const port = 6969;
const server = http.createServer(express);
const wss = new WebSocket.Server({ server })
So here what’s going on is we are just doing the usual requires, we pull in express, ws and you might have spotted http as well. We use http so we can initialise a server, and we pass express in there like so: const server = http.createServer(express); along with setting the port to 6969. Lastly, we assign the new WebSocket to wss.
wss.on(‘connection’, function connection(ws) {</p>
<blockquote>
<div><dl>
<dt>ws.on(‘message’, function incoming(data) {</dt><dd><dl>
<dt>wss.clients.forEach(function each(client) {</dt><dd><dl class="simple">
<dt>if (client !== ws &amp;&amp; client.readyState === WebSocket.OPEN) {</dt><dd><p>client.send(data);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>})</p>
</dd>
</dl>
<p>})</p>
</div></blockquote>
<p>})
Next, we listen for a connection on our newly initialised WebSocket by doing wss.on(‘connection’, function connection(ws) { - I named this wss to remind myself that this is the WebSocket Server, but feel free to name this as you like.
Once we have the connection, we listen for a message from the client, next, you’ll see that we have a function called incoming, this function gives us data which is the users’ messages from the front-end (we will come to the front-end part shortly); we will use data later on to send it to all the connected clients.
So now we have the data (the messages), sent from the clients, we want to broadcast that message to each client (apart from the sending client). Next, we run a forEach loop over each connected client, and then we use an if statement to make sure that the client is connected and the socket is open–an important aspect of this if statement is that we are also checking that we are not sending the message back to the client who sent the message!. If that statement comes back as true, we then broadcast the message using: client.send(data);.
server.listen(port, function() {</p>
<blockquote>
<div><p>console.log(<cite>Server is listening on ${port}!</cite>)</p>
</div></blockquote>
<p>})
Lastly, for the server.js file, we just listen on our port that we set above–this is just standard Express!
Okay, phew we’re done with the server.js file, now onto the index.html file.
&lt;h1&gt;Real Time Messaging&lt;/h1&gt;
&lt;pre id=”messages” style=”height: 400px; overflow: scroll”&gt;&lt;/pre&gt;
&lt;input type=”text” id=”messageBox” placeholder=”Type your message here” style=”display: block; width: 100%; margin-bottom: 10px; padding: 10px;” /&gt;
&lt;button id=”send” title=”Send Message!” style=”width: 100%; height: 30px;”&gt;Send Message&lt;/button&gt;
Here we’re creating a box so we can see our messages that are sent from the clients (as well as our own sent messages), secondly, we then create an input that allows the user to input a message, and finally…we create a button that allows a user to send a message!
I’m going to presume you already know what the script tags do, but what does (function() {})() do? Well, that’s an immediately invoked function! An immediately invoked function expression just runs as soon as it’s defined. So as soon as we call define this function, we invoke the function–basically we run it.
const sendBtn = document.querySelector(‘#send’);
const messages = document.querySelector(‘#messages’);
const messageBox = document.querySelector(‘#messageBox’);
Here, we’re just selecting our button, messages, and input DOM elements. Once we’ve got those selected, we go ahead and create an empty expression let ws; we need this later on.
function showMessage(message) {</p>
<blockquote>
<div><p>messages.textContent += <cite>nn${message}</cite>;
messages.scrollTop = messages.scrollHeight;
messageBox.value = ‘’;</p>
</div></blockquote>
<p>}
Here what we’re doing is just having a function that we can call when we pass it a message, it just goes in and uses the messages selector, adds the text and then we clear the sent message from the user’s message box.
function init() {</p>
<blockquote>
<div><dl class="simple">
<dt>if (ws) {</dt><dd><p>ws.onerror = ws.onopen = ws.onclose = null;
ws.close();</p>
</dd>
</dl>
<p>}</p>
<p>ws = new WebSocket(‘ws://localhost:6969’);
ws.onopen = () =&gt; {</p>
<blockquote>
<div><p>console.log(‘Connection opened!’);</p>
</div></blockquote>
<p>}
ws.onmessage = ({ data }) =&gt; showMessage(data);
ws.onclose = function() {</p>
<blockquote>
<div><p>ws = null;</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
The init function is basically built so that we can separate out our implementation of the connection to the server. What we do is we check if there’s a connection already for the user if there is a connection, we go ahead and null the connection and then close it. Following that, if the user doesn’t have a connection, we initialise a new connection to the server ws = new WebSocket(‘ws://localhost:6969’);.
Once we have a connection to the server, we simply console.log a message that states we have successfully connected to the server.
ws.onopen = () =&gt; {</p>
<blockquote>
<div><p>console.log(‘Connection opened!’);</p>
</div></blockquote>
<p>}
Following the above, we then proceed to check for a message. If there’s a message we pass it to showMessage, and we then add it to the chatbox by using our function that we created earlier. Lastly, if the connection closes, we just null that particular connection by using ws = null;.
Furthermore, we then find ourselves at the sendBtn part of the code, now this is quite self-explanatory, but let’s make sure we fully understand what is going on here.
So we have sendBtn.onclick, which is our trigger to send a message. We first check if there’s currently not an active web socket connection by checking if (!ws). The reason we do this is that we don’t want to try to send a message if there’s no web socket connection. If there isn’t a web socket connection, we just return No WebSocket connection :(. If there is a web socket connection, we fire the message to the server with ws.send(messageBox.value), we then show the message in our message box.
And lastly, the most important part, we run our init function by invoking it with init();.
And we are done!
To run the server, just use yarn start and you should see Server is listening on 6969!. Then if you go ahead and open up index.html in your browser (try it in 2 different browsers), you’ll see that if you send a message in one of the windows, you’ll get the sent messages to appear in all your open browser connections!
—
🎥 If you enjoyed this little tip, subscribe to my YouTube channel where I post React, JavaScript, GraphQL videos — and of course quick tips! I’m also on Twitter — feel free to &#64; me with any questions!</p>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="页脚">
        <a href="index.html" class="btn btn-neutral float-left" title="Blogs" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版权所有 2019-2021, BandCap.</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用的 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a> 开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>